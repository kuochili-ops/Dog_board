<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-End Mesh Doggy</title>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { max-width: 100%; max-height: 80vh; cursor: pointer; }
        .ui { position: fixed; bottom: 30px; display: flex; gap: 10px; z-index: 10; }
        input { padding: 12px 20px; border-radius: 25px; border: none; width: 250px; font-size: 16px; }
        button { padding: 12px 25px; border-radius: 25px; border: none; background: #ff4757; color: white; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="ui">
    <input type="text" id="textInput" placeholder="輸入要叼起的文字...">
    <button onclick="triggerAction()">送出</button>
</div>

<script>
/**
 * 網格變形引擎模組 [cite: 2025-12-19]
 */
class MeshEngine {
    constructor(canvas, imageSrc, rows, cols) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.rows = rows;
        this.cols = cols;
        this.img = new Image();
        this.img.src = imageSrc;
        this.points = [];
        this.isLoaded = false;
        this.progress = 0; // 0: 平常, 1: 低頭最深處
        
        this.img.onload = () => {
            this.canvas.width = this.img.width;
            this.canvas.height = this.img.height;
            this.initMesh();
            this.isLoaded = true;
            this.render();
        };
    }

    initMesh() {
        for (let r = 0; r <= this.rows; r++) {
            for (let c = 0; c <= this.cols; c++) {
                const x = (c / this.cols) * this.img.width;
                const y = (r / this.rows) * this.img.height;
                this.points.push({ ox: x, oy: y, x: x, y: y });
            }
        }
    }

    update(targetProgress) {
        // 使用簡單緩動趨向目標進度
        this.progress += (targetProgress - this.progress) * 0.15;
        
        const maxOffset = this.img.height / 3; // 設定位移為 1/3 處 [cite: 2025-12-28]
        const expansion = 60; // 3D 外擴強度 [cite: 2025-12-28]

        this.points.forEach((p, i) => {
            const r = Math.floor(i / (this.cols + 1));
            const c = i % (this.cols + 1);
            
            // 計算權重：上方高、下方低 [cite: 2025-12-28]
            const weight = Math.pow(1 - (r / this.rows), 2.5);
            
            // 垂直位移
            p.y = p.oy + (maxOffset * this.progress * weight);
            
            // 水平 3D 外擴 (依據中心點偏移) [cite: 2025-12-28]
            const centerX = this.img.width / 2;
            const dir = p.ox < centerX ? -1 : 1;
            const distFromCenter = Math.abs(p.ox - centerX) / centerX;
            p.x = p.ox + (expansion * this.progress * weight * dir * distFromCenter);
        });
    }

    render() {
        if (!this.isLoaded) return;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                this.drawTriangleSlice(r, c, true);
                this.drawTriangleSlice(r, c, false);
            }
        }
        requestAnimationFrame(() => this.render());
    }

    drawTriangleSlice(r, c, isUpper) {
        const i1 = r * (this.cols + 1) + c;
        const i2 = i1 + 1;
        const i3 = (r + 1) * (this.cols + 1) + c;
        const i4 = i3 + 1;

        const p1 = this.points[i1], p2 = this.points[i2], p3 = this.points[i3], p4 = this.points[i4];
        
        // 取得三角形三個頂點 (拆分成兩個三角形渲染)
        const tri = isUpper ? [p1, p2, p3] : [p2, p4, p3];

        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.moveTo(tri[0].x, tri[0].y);
        this.ctx.lineTo(tri[1].x, tri[1].y);
        this.ctx.lineTo(tri[2].x, tri[2].y);
        this.ctx.closePath();
        this.ctx.clip();

        // 仿射變換計算 (這部分處理圖片切片的扭曲)
        const x0 = tri[0].x, y0 = tri[0].y, x1 = tri[1].x, y1 = tri[1].y, x2 = tri[2].x, y2 = tri[2].y;
        const u0 = tri[0].ox, v0 = tri[0].oy, u1 = tri[1].ox, v1 = tri[1].oy, u2 = tri[2].ox, v2 = tri[2].oy;

        const det = u0 * (v1 - v2) + u1 * (v2 - v0) + u2 * (v0 - v1);
        const a = (x0 * (v1 - v2) + x1 * (v2 - v0) + x2 * (v0 - v1)) / det;
        const b = (y0 * (v1 - v2) + y1 * (v2 - v0) + y2 * (v0 - v1)) / det;
        const d = (x0 * (u2 - u1) + x1 * (u0 - u2) + x2 * (u1 - u0)) / det;
        const e = (y0 * (u2 - u1) + y1 * (u0 - u2) + y2 * (u1 - u0)) / det;
        const f = (x0 * (u1 * v2 - u2 * v1) + x1 * (u2 * v0 - u0 * v2) + x2 * (u0 * v1 - u1 * v0)) / det;
        const g = (y0 * (u1 * v2 - u2 * v1) + y1 * (u2 * v0 - u0 * v2) + y2 * (u0 * v1 - u1 * v0)) / det;

        this.ctx.setTransform(a, b, d, e, f, g);
        this.ctx.drawImage(this.img, 0, 0);
        this.ctx.restore();
    }
}

// 初始化
const engine = new MeshEngine(document.getElementById('canvas'), 'IMG_5730.png', 20, 20);

let target = 0;
function triggerAction() {
    target = 1; // 低頭
    setTimeout(() => {
        target = 0; // 抬頭
    }, 1200);
}

// 持續更新物理進度
function tick() {
    engine.update(target);
    setTimeout(tick, 16);
}
tick();

</script>
</body>
</html>
