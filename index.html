<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Blackboard Texture Sync</title>
    <style>
        body { background: #000; color: #fff; margin: 0; display: flex; flex-direction: column; align-items: center; }
        .stage { position: relative; width: 100%; max-width: 800px; perspective: 1500px; }
        video { width: 100%; display: block; }

        /* 文字圖形層 */
        #textSticker {
            position: absolute;
            /* 定位到黑板在影片中的最終中心範圍 */
            top: 54.5%; 
            left: 55%;
            width: 32%; 
            height: 42%;
            
            pointer-events: none;
            z-index: 10;
            
            /* 關鍵：旋轉軸心固定在黑板上緣（吊繩處） */
            transform-origin: center top; 
            
            /* 初始狀態：背對觀眾 (180度) 或水平 (-90度) */
            transform: translate(-50%, 0%) rotateX(-105deg);
            opacity: 0;
            
            /* 修正渲染品質 */
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            will-change: transform, opacity;
        }

        /* 逆向工程：手動對齊 dog_board.mp4 的運動軌跡 */
        @keyframes preciseStickerFlip {
            0% {
                opacity: 0;
                transform: translate(-50%, -5%) rotateX(-105deg) rotateY(20deg) scale(0.85);
            }
            /* 1.5s: 黑板翻到一半，文字開始受光顯現 */
            45% {
                opacity: 1;
                transform: translate(-51%, -3%) rotateX(-75deg) rotateY(18deg) rotateZ(-3deg) scale(0.95);
            }
            /* 2.2s: 翻轉接近垂直，模擬叼起的慣性抖動 */
            75% {
                opacity: 1;
                transform: translate(-53%, -2%) rotateX(-15deg) rotateY(12deg) rotateZ(-1deg) scale(1.05);
            }
            /* 2.8s: 最終畫面校準 (左高右低透視) */
            100% {
                opacity: 1;
                /* 最終角度：微調 Y 軸與 Z 軸以完全貼合黑板平面 */
                transform: translate(-53.5%, 0%) rotateX(0deg) rotateY(14deg) rotateZ(0deg) scale(1.1);
            }
        }

        .active {
            animation: preciseStickerFlip 3.5s linear forwards;
        }

        .ui { padding: 20px; width: 100%; max-width: 400px; }
        input { width: 100%; padding: 15px; margin-bottom: 10px; border-radius: 8px; border: none; font-size: 16px; background: #222; color: #fff; }
        button { width: 100%; padding: 15px; background: #FFD700; color: #000; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

    <div class="stage">
        <video id="v" playsinline webkit-playsinline muted>
            <source src="dog_board.mp4" type="video/mp4">
        </video>
        <canvas id="textSticker"></canvas>
    </div>

    <div class="ui">
        <input type="text" id="userInput" placeholder="輸入要刻在黑板的話...">
        <button onclick="applyTextureSync()">執行同步翻轉</button>
    </div>

    <script>
        const canvas = document.getElementById('textSticker');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('v');
        const input = document.getElementById('userInput');

        // 將輸入文字轉化為符合黑板尺寸的圖形
        function drawTextTexture(text) {
            canvas.width = 512;  // 高解析度紋理
            canvas.height = 384;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 繪製白色粉筆感文字
            ctx.fillStyle = "white";
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.shadowBlur = 4;
            ctx.font = "900 60px sans-serif"; // 粗體增強識別
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // 自動斷行處理 (簡單版)
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        }

        function applyTextureSync() {
            drawTextTexture(input.value || "這下同步了！");
            
            // 徹底重置
            canvas.classList.remove('active');
            video.pause();
            video.currentTime = 0;
            
            void canvas.offsetWidth; // 觸發重繪
            
            // 同步啟動
            video.play();
            canvas.classList.add('active');
        }
    </script>
</body>
</html>
